  //planning secene monitor, then planning scene instance creation for collision checking
  boost::shared_ptr<tf::TransformListener> tf(new tf::TransformListener());
  ROS_INFO("Got a transform listener.");
  planning_scene_monitor::PlanningSceneMonitor psm(ROBOT_DESCRIPTION, tf);
  psm.startStateMonitor();
  psm.startWorldGeometryMonitor(planning_scene_monitor::PlanningSceneMonitor::DEFAULT_COLLISION_OBJECT_TOPIC, planning_scene_monitor::PlanningSceneMonitor::DEFAULT_PLANNING_SCENE_WORLD_TOPIC);
  psm.startSceneMonitor(SCENE_TOPIC);
  ROS_INFO("Got a scene monitor.");
  planning_scene::PlanningScenePtr planning_scene(psm.getPlanningScene());
  ROS_INFO("Requesting current planning scene state ... %d.", psm.requestPlanningSceneState("/get_planning_scene"));
  sleep_t.sleep();
  ROS_INFO("Created a planning scene object.");

  //Create a playground world, then a collision world. They will be used to test various swept volumes for collision.
  collision_detection::WorldPtr world(new collision_detection::World());
  collision_detection::CollisionWorldFCL cWorld(world);
  collision_detection::CollisionWorldConstPtr robotWorld = planning_scene->getCollisionWorld();
  collision_detection::CollisionRobotConstPtr collisionRobot = planning_scene->getCollisionRobot();
  ROS_INFO("Created collision world. Planning scene has size() = %d.", robotWorld->getWorld()->size());

  //Get package path.
  std::string packagePath = "package://armsweep";//ros::package::getPath("armsweep");
  //Load a simple mesh.
  std::string fileName = packagePath+"/res/cube.stl";
  shapes::Mesh *cubeMesh = shapes::createMeshFromResource(fileName, Eigen::Vector3d(1, 1, 1));
  shapes::ShapeConstPtr cubeShape(cubeMesh);
  Eigen::Affine3d initPose;
  initPose(0, 0) = initPose(1, 1) = initPose(2, 2) = initPose(3, 3) = 1;
  initPose(0, 1) = initPose(0, 2) = initPose(0, 3) = initPose(1, 0) = 0;
  initPose(1, 2) = initPose(1, 3) = initPose(2, 0) = initPose(2, 1) = 0;
  initPose(2, 3) = initPose(3, 0) = initPose(3, 1) = initPose(3, 2) = 0;
  initPose(3, 0) = initPose(3, 1) = 0.05;
  ROS_INFO("Loaded meshes.");
  world->addToObject("cube", cubeShape, initPose);
  ROS_INFO("Collision world now has size() = %d.", world->size());


  //publisher for visualizing plans in Rviz.
  //ros::Publisher display_publisher = node_handle.advertise<moveit_msgs::DisplayTrajectory>("/move_group/display_planned_path", 1, true);
  //moveit_msgs::DisplayTrajectory display_trajectory;

  //Publisher for planning scene diffs: used to modify the planning scene by adding/removing objects. 
  //NOTE: this is for debug/visualizing purposes here; will not be used in the full system
  ros::Publisher planning_scene_diff_publisher = node_handle.advertise<moveit_msgs::PlanningScene>(SCENE_TOPIC, 1);
  while(planning_scene_diff_publisher.getNumSubscribers() < 1)
  {
    sleep_t.sleep();
  }
  ros::Publisher collision_object_publisher = node_handle.advertise<moveit_msgs::CollisionObject>("collision_object", 1);
  while(collision_object_publisher.getNumSubscribers() < 1)
  {
    ros::WallDuration sleep_t(0.5);
    sleep_t.sleep();
  }
  ROS_INFO("Advertized production of planning_scene_diff messages.");

  shape_msgs::Mesh meshMsg;
  geometry_msgs::Pose poseMsg;
  meshToMsg(cubeMesh, &meshMsg);
  tf::poseEigenToMsg(initPose, poseMsg);

  collision_detection::CollisionRequest req;
  collision_detection::CollisionResult res;
  req.verbose = true;
#if 1
  moveit_msgs::CollisionObject add_object;
  add_object.id = "cube";
  add_object.header.frame_id = "odom_combined";
  add_object.operation = add_object.ADD;
  add_object.meshes.push_back(meshMsg);
  add_object.mesh_poses.push_back(poseMsg);
  moveit_msgs::CollisionObject collisionObjectMsg;
  collisionObjectMsg.id = "cube";
  collisionObjectMsg.header.frame_id = "odom_combined";
  collisionObjectMsg.operation = collisionObjectMsg.ADD;
  collisionObjectMsg.meshes.push_back(meshMsg);
  collisionObjectMsg.mesh_poses.push_back(poseMsg);

  collision_object_publisher.publish(add_object);
  ROS_INFO("Sent add_object message.");
  sleep_t.sleep();

  moveit_msgs::PlanningScene planning_scene_diff;
  geometry_msgs::TransformStamped transformStampedMsg;
  transformStampedMsg.header.frame_id = "odom_combined";
  transformStampedMsg.transform.translation.x = 0;
  transformStampedMsg.transform.translation.y = 0;
  transformStampedMsg.transform.translation.z = 0;
  transformStampedMsg.transform.rotation.w = 1;
  transformStampedMsg.transform.rotation.x = 0;
  transformStampedMsg.transform.rotation.y = 0;
  transformStampedMsg.transform.rotation.z = 0;
  //planning_scene_diff.fixed_frame_transforms.push_back(transformStampedMsg);
  planning_scene_diff.world.collision_objects.push_back(collisionObjectMsg);
  planning_scene_diff.is_diff = true;
  ROS_INFO("Prepared diff message.");
  planning_scene_diff_publisher.publish(planning_scene_diff);
  ROS_INFO("Sent diff message.");
  sleep_t.sleep();
#endif

  ROS_INFO("Planning scene has size() = %d.", robotWorld->getWorld()->size());
#if 0
  robotWorld->checkWorldCollision(req, res, cWorld);
  if(res.collision)
  {
      ROS_INFO("Detected a collision between loaded mesh and planning scene.");
  }
  else
  {
      ROS_INFO("No collision detected between loaded mesh and planning scene.");
  }
#else
  ROS_INFO("Doing collision testing on own copy of planning scene.");
  ROS_INFO("Collision world now has size() = %d.", planning_scene->getWorldNonConst()->size());
  planning_scene->getWorldNonConst()->addToObject("cube2", cubeShape, initPose);
  ROS_INFO("Collision world now has size() = %d.", planning_scene->getWorldNonConst()->size());
  collision_detection::AllowedCollisionMatrix acm(planning_scene->getAllowedCollisionMatrix());
  acm.setEntry("cube", "base_link", true);
  acm.setEntry("cube2", "base_link", true);
  robot_state::RobotState crState(planning_scene->getCurrentState());
  planning_scene->checkCollision(req, res, crState);
  if(res.collision)
  {
      ROS_INFO("Detected a collision between loaded mesh and planning scene.");
  }
  else
  {
      ROS_INFO("No collision detected between loaded mesh and planning scene.");
  }
  res.clear();
  planning_scene->checkCollision(req, res, crState, acm);
  if(res.collision)
  {
      ROS_INFO("Detected a collision between loaded mesh and planning scene.");
  }
  else
  {
      ROS_INFO("No collision detected between loaded mesh and planning scene.");
  }
  res.clear();
  planning_scene->getWorldNonConst()->removeObject("cube");
  ROS_INFO("Collision world now has size() = %d.", planning_scene->getWorldNonConst()->size());
#endif

